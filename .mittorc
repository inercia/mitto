# Mitto workspace-specific configuration
# These prompts are available only when working in this project

prompts:
  - name: "Architecture Cleanup"
    backgroundColor: "#E8F5E9"  # Light Green - improvement/quality
    prompt: |
      Please perform an architectural review and cleanup of the codebase:

      1. **Identify Architectural Issues**:
         - Look for circular dependencies between packages
         - Find code that violates separation of concerns
         - Detect tightly coupled components that should be decoupled
         - Identify packages with too many responsibilities

      2. **Refactor for Modularity**:
         - Extract interfaces where concrete types are used directly
         - Move shared utilities to appropriate packages
         - Ensure each package has a clear, single responsibility
         - Apply dependency injection where appropriate

      3. **Add Valuable Tests**:
         - Identify critical paths lacking test coverage
         - Add unit tests for core business logic
         - Add integration tests for component interactions
         - Focus on tests that prevent regressions and document behavior

      4. **Follow Project Conventions**:
         - Review .augment/rules for project-specific patterns
         - Maintain existing code style and naming conventions
         - Update architecture documentation if needed

      Please start by analyzing the current state and proposing a prioritized plan
      before making any changes. Focus on high-impact, low-risk improvements first.

  - name: "Run All Tests"
    backgroundColor: "#BBDEFB"  # Light Blue - testing/verification
    prompt: |
      Please run the complete test suite for this project and fix any failures:

      ## Test Execution Order

      1. **Go Unit Tests**:
         ```bash
         make test-go
         ```

      2. **JavaScript Unit Tests**:
         ```bash
         make test-js
         ```

      3. **Integration Tests** (requires mock ACP server):
         ```bash
         make test-integration
         ```

      4. **Playwright UI Tests**:
         ```bash
         make test-ui
         ```

      Or run everything at once:
      ```bash
      make test-all
      ```

      ## On Failure

      If any test fails:
      1. Analyze the failure output carefully
      2. Identify the root cause (code bug, test bug, or environment issue)
      3. Fix the issue in the appropriate location
      4. Re-run the specific failing test to verify the fix
      5. Run the full test suite again to ensure no regressions

      ## Important Notes

      - Build the mock ACP server first if needed: `make build-mock-acp`
      - For first-time setup: `make test-setup` (installs Playwright browsers)
      - Check `tests/README.md` and `.augment/rules/07-testing.md` for conventions
      - Ensure fixes follow existing code patterns and test conventions

      Please start by running the tests and report the results.

  - name: "Create PR"
    backgroundColor: "#F3E5F5"  # Light Purple - workflow/process
    prompt: |
      Please help me create a Pull Request with the following workflow:

      ## Step 1: Format Code

      Run code formatters to ensure consistent style:
      ```bash
      make fmt
      ```

      Report any formatting changes made.

      ## Step 2: Analyze & Commit Changes

      1. Run `git status --porcelain` to list all uncommitted changes
      2. Group related changes logically by:
         - Feature or component they belong to
         - Type of change (feature, fix, refactor, test, docs, chore)
         - File path patterns
      3. Propose commits using conventional commit prefixes:
         - `feat:` for new features
         - `fix:` for bug fixes
         - `docs:` for documentation changes
         - `refactor:` for code refactoring
         - `test:` for test additions or modifications
         - `chore:` for maintenance tasks
      4. Present a table with the proposed commits:

         | SEQUENCE | COMMIT MESSAGE | FILES | REASON |
         |----------|----------------|-------|--------|
         | 1 | feat: add new feature | file1.go, file2.go | Related feature files |
         | ... | ... | ... | ... |

      5. **WAIT FOR MY APPROVAL** before making any commits
      6. After approval, execute the commits in sequence

      ## Step 3: Verify CI

      Run CI checks to ensure they will pass:
      ```bash
      make ci
      ```

      Report any failures and fix them before proceeding.

      ## Step 4: Create Pull Request

      Use GitHub CLI to create the PR:
      ```bash
      gh pr create --title "<title>" --body "<description>"
      ```

      - Generate an appropriate title based on the commits
      - Create a comprehensive description summarizing all changes
      - Include any relevant context or testing notes

      Report success or any errors after each step.

  - name: "Create Release"
    backgroundColor: "#FFF3E0"  # Light Orange - release/deployment
    prompt: |
      Please help me create a new release with the following workflow:

      ## Step 1: Format Code

      Run code formatters to ensure consistent style:
      ```bash
      make fmt
      ```

      Report any formatting changes made.

      ## Step 2: Analyze & Commit Changes

      1. Run `git status --porcelain` to list all uncommitted changes
      2. If there are uncommitted changes, group them logically by:
         - Feature or component they belong to
         - Type of change (feature, fix, refactor, test, docs, chore)
         - File path patterns
      3. Propose commits using conventional commit prefixes:
         - `feat:` for new features
         - `fix:` for bug fixes
         - `docs:` for documentation changes
         - `refactor:` for code refactoring
         - `test:` for test additions or modifications
         - `chore:` for maintenance tasks
      4. Present a table with the proposed commits:

         | SEQUENCE | COMMIT MESSAGE | FILES | REASON |
         |----------|----------------|-------|--------|
         | 1 | feat: add new feature | file1.go, file2.go | Related feature files |
         | ... | ... | ... | ... |

      5. **WAIT FOR MY APPROVAL** before making any commits
      6. After approval, execute the commits in sequence

      ## Step 3: Verify CI

      Run CI checks to ensure they will pass:
      ```bash
      make ci
      ```

      Report any failures and fix them before proceeding.

      ## Step 4: Determine Version

      1. Get the latest tag: `git describe --tags --abbrev=0`
      2. Analyze commits since the last tag using conventional commit prefixes:
         - `feat:` commits → suggest MINOR version bump
         - `fix:` commits → suggest PATCH version bump
         - Breaking changes (indicated by `!` or `BREAKING CHANGE:`) → suggest MAJOR version bump
      3. Present the suggested version with reasoning:
         - Current version: vX.Y.Z
         - Suggested version: vX.Y.Z
         - Reason: List of relevant commits

      4. **WAIT FOR MY APPROVAL** of the version number

      ## Step 5: Create & Push Tag

      After version approval:
      ```bash
      git tag -a <version> -m "Release <version>"
      git push origin <version>
      ```

      Report success or any errors after each step.

