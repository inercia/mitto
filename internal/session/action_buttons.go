// Package session provides session persistence and management for Mitto.
package session

import (
	"os"
	"path/filepath"
	"sync"
	"time"

	"github.com/inercia/mitto/internal/fileutil"
)

const (
	actionButtonsFileName = "action_buttons.json"
)

// ActionButton represents a suggested follow-up action for the user.
//
// These are generated by analyzing agent messages for questions or prompts
// using the auxiliary conversation. They provide quick-tap responses that
// help users continue conversations without typing, especially on mobile.
//
// Example suggestions for "Would you like me to proceed?":
//   - Label: "Yes, proceed"    Response: "Yes, please proceed with the changes"
//   - Label: "Show diff first" Response: "Can you show me the diff before proceeding?"
type ActionButton struct {
	// Label is the button text displayed to the user (max 50 chars).
	// Should be short and action-oriented.
	Label string `json:"label"`
	// Response is the full text sent when the user clicks the button (max 1000 chars).
	// Can be more detailed than the label.
	Response string `json:"response"`
}

// ActionButtonsFile represents the persisted action buttons state.
//
// This is stored as action_buttons.json in the session directory. Unlike the
// append-only events.jsonl, this file is replaced entirely when buttons change
// and deleted when buttons are cleared. This reflects the transient nature of
// suggestionsâ€”they're UI state, not conversation history.
type ActionButtonsFile struct {
	// Buttons is the list of suggested action buttons.
	Buttons []ActionButton `json:"buttons"`
	// GeneratedAt is when the buttons were generated.
	GeneratedAt time.Time `json:"generated_at"`
	// ForEventSeq tracks which agent message these suggestions relate to.
	// Used for debugging and to detect stale suggestions.
	ForEventSeq int64 `json:"for_event_seq,omitempty"`
}

// ActionButtonsStore manages the action buttons for a single session.
//
// It provides disk persistence so suggestions survive server restarts and
// can be sent to clients that connect after suggestions were generated.
// This solves the problem of ephemeral suggestions being lost when users
// switch devices or refresh their browser.
//
// Thread-safe: all methods can be called concurrently.
type ActionButtonsStore struct {
	sessionDir string
	mu         sync.Mutex
}

// NewActionButtonsStore creates a new ActionButtonsStore for the given session directory.
func NewActionButtonsStore(sessionDir string) *ActionButtonsStore {
	return &ActionButtonsStore{
		sessionDir: sessionDir,
	}
}

// actionButtonsPath returns the path to the action buttons file.
func (s *ActionButtonsStore) actionButtonsPath() string {
	return filepath.Join(s.sessionDir, actionButtonsFileName)
}

// read reads the action buttons file from disk.
// Returns an empty ActionButtonsFile if the file doesn't exist.
func (s *ActionButtonsStore) read() (*ActionButtonsFile, error) {
	var abf ActionButtonsFile
	err := fileutil.ReadJSON(s.actionButtonsPath(), &abf)
	if err != nil {
		if os.IsNotExist(err) {
			return &ActionButtonsFile{Buttons: []ActionButton{}}, nil
		}
		return nil, err
	}
	if abf.Buttons == nil {
		abf.Buttons = []ActionButton{}
	}
	return &abf, nil
}

// write writes the action buttons file to disk atomically.
func (s *ActionButtonsStore) write(abf *ActionButtonsFile) error {
	return fileutil.WriteJSONAtomic(s.actionButtonsPath(), abf, 0644)
}

// Get returns the current action buttons.
// Returns an empty slice (not nil) if no buttons are stored or file doesn't exist.
// The returned slice is a copy, safe to modify.
func (s *ActionButtonsStore) Get() ([]ActionButton, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	abf, err := s.read()
	if err != nil {
		return nil, err
	}

	// Return a copy to prevent external modification of internal state
	result := make([]ActionButton, len(abf.Buttons))
	copy(result, abf.Buttons)
	return result, nil
}

// Set stores the action buttons, replacing any existing ones.
// Called after the auxiliary conversation analyzes an agent response.
// forEventSeq tracks which agent message these suggestions relate to,
// useful for debugging stale suggestion issues.
func (s *ActionButtonsStore) Set(buttons []ActionButton, forEventSeq int64) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	abf := &ActionButtonsFile{
		Buttons:     buttons,
		GeneratedAt: time.Now(),
		ForEventSeq: forEventSeq,
	}
	return s.write(abf)
}

// Clear removes all action buttons by deleting the file.
// Called when the user sends a new prompt, since the old suggestions
// become stale and new ones will be generated for the next response.
// Deleting the file (vs writing empty) reduces disk clutter.
func (s *ActionButtonsStore) Clear() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	err := os.Remove(s.actionButtonsPath())
	if err != nil && !os.IsNotExist(err) {
		return err
	}
	return nil
}

// IsEmpty returns true if there are no action buttons stored.
func (s *ActionButtonsStore) IsEmpty() (bool, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	abf, err := s.read()
	if err != nil {
		return true, err
	}
	return len(abf.Buttons) == 0, nil
}

// Delete removes the action buttons file from disk.
// Called during session deletion to clean up all session files.
// Equivalent to Clear() but semantically indicates permanent removal.
func (s *ActionButtonsStore) Delete() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	err := os.Remove(s.actionButtonsPath())
	if err != nil && !os.IsNotExist(err) {
		return err
	}
	return nil
}
