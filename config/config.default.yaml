# Mitto Default Configuration
# This file contains the default settings that are used when settings.json doesn't exist.
# Your personal settings are stored in settings.json in your Mitto data directory:
#   - macOS: ~/Library/Application Support/Mitto/settings.json
#   - Linux: ~/.local/share/mitto/settings.json
#   - Windows: %APPDATA%\Mitto\settings.json

acp:
  - auggie:
      command: auggie --acp
      prompts:
        - name: Improve rules
          prompt: |
            Review and update the Augment rules in `.augment/rules` based on all insights,
            patterns, and lessons learned from our recent conversations and code changes.
            Specifically:

            1. Add any new architectural patterns or components that have been introduced
            2. Document new conventions, best practices, or anti-patterns discovered during implementation
            3. Update existing sections if they are outdated or incomplete
            4. Add new sections for areas not currently covered (e.g., new packages, APIs, frontend patterns)
            5. Ensure examples reflect the current codebase state

            Focus on actionable guidance that will help future development sessions
             Do not remove existing valid content - only add or update information.

  - claude-code:
      command: npx -y @zed-industries/claude-code-acp@latest

# Global prompts - available for all ACP servers
# Grouped by scope with matching colors for visual organization
prompts:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WORKFLOW & PROGRESS (Blue) - Task management and planning
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - name: "Continue"
    backgroundColor: "#BBDEFB"  # Light Blue
    prompt: |
      Continue with the current task from where we left off.

      1. Review the current state and what has been completed
      2. Identify the next immediate step
      3. Execute that step
      4. Report progress and what remains

      If blocked or unclear, ask for clarification before proceeding.

  - name: "Propose a plan"
    backgroundColor: "#BBDEFB"  # Light Blue
    prompt: |
      Create a detailed plan for the current task.

      ### Structure your plan as:

      1. **Goal**: What we're trying to achieve
      2. **Current state**: What exists now, what's missing
      3. **Steps**: Numbered list of concrete actions
         - Include file paths and function names where applicable
         - Estimate complexity (simple/medium/complex) for each step
         - Note dependencies between steps
      4. **Risks**: Potential issues and how to mitigate them
      5. **Verification**: How we'll know the task is complete

      Present the plan and wait for approval before executing.

  - name: "What's next?"
    backgroundColor: "#BBDEFB"  # Light Blue
    prompt: |
      Analyze our progress and suggest next steps.

      ### Review:

      1. **Completed**: What we've accomplished so far
      2. **Current state**: Where the code/project stands now
      3. **Remaining work**: What's left to do for the original goal

      ### Suggest next steps:

      Present a prioritized list:

      | Priority | Task | Reason | Effort |
      |----------|------|--------|--------|
      | 1 | ... | ... | Small/Medium/Large |

      ### Consider:
      - Dependencies (what must come before what)
      - Risk (tackle risky items early)
      - Value (high-impact items first)
      - Blockers (anything preventing progress)

      Ask if I want to proceed with the top priority item.

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CODE QUALITY (Green) - Refactoring, simplification, and review
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - name: "Review"
    backgroundColor: "#C8E6C9"  # Light Green
    prompt: |
      Review the changes we made for quality and correctness.

      ### Check for:

      1. **Bugs**: Logic errors, off-by-one, null/nil handling, race conditions
      2. **Security**: Input validation, injection risks, auth/authz issues, secrets exposure
      3. **Performance**: Unnecessary allocations, N+1 queries, blocking calls, memory leaks
      4. **Error handling**: Missing error checks, unhelpful messages, swallowed errors
      5. **Style**: Consistency with codebase, naming conventions, formatting
      6. **Tests**: Adequate coverage, meaningful assertions, edge cases

      ### Report format:

      For each issue found:
      - **Severity**: Critical / High / Medium / Low
      - **Location**: File and line number
      - **Issue**: What's wrong
      - **Suggestion**: How to fix it

      Summarize: total issues by severity, overall assessment, recommended actions.

  - name: "Refactor"
    backgroundColor: "#C8E6C9"  # Light Green
    prompt: |
      Refactor the current code for better quality.

      ### Focus areas:

      1. **Naming**: Use clear, descriptive names for variables, functions, types
      2. **Structure**: Organize code logically, group related functionality
      3. **Single responsibility**: Each function/class does one thing well
      4. **DRY**: Extract repeated patterns into reusable components
      5. **Error handling**: Consistent, informative error messages
      6. **Idioms**: Follow language-specific best practices and conventions

      ### Process:
      - Make one type of change at a time
      - Run tests after each change to catch regressions
      - Preserve external behavior (this is refactoring, not rewriting)

      ### Document:
      - List each refactoring applied
      - Explain the benefit of each change

  - name: "Simplify"
    backgroundColor: "#C8E6C9"  # Light Green
    prompt: |
      Simplify the current implementation while preserving functionality.

      ### Look for:

      1. **Redundant code**: Duplicate logic that can be consolidated
      2. **Over-engineering**: Abstractions that add complexity without value
      3. **Deep nesting**: Flatten conditionals using early returns or guard clauses
      4. **Long functions**: Break into smaller, focused functions
      5. **Complex conditionals**: Simplify boolean logic, use lookup tables
      6. **Unnecessary state**: Remove variables that can be computed on demand

      ### For each change:
      - Explain what you're simplifying and why
      - Show before/after comparison
      - Verify behavior is preserved

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # TESTING & DEBUGGING (Orange/Amber) - Tests and error fixing
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - name: "Add tests"
    backgroundColor: "#FFE0B2"  # Light Orange
    prompt: |
      Write comprehensive tests for the code we created or modified.

      ### Include tests for:

      1. **Happy path**: Normal expected usage
      2. **Edge cases**: Empty inputs, boundary values, maximum sizes
      3. **Error cases**: Invalid inputs, missing data, permission errors
      4. **Concurrency**: Race conditions, deadlocks (if applicable)
      5. **Integration**: Interaction with dependencies

      ### Test structure:
      - Use descriptive test names that explain the scenario
      - Follow Arrange-Act-Assert pattern
      - One assertion per test when possible
      - Use table-driven tests for multiple similar cases
      - Mock external dependencies appropriately

      ### After writing:
      - Run the tests and verify they pass
      - Check coverage of the new/modified code

  - name: "Run tests"
    backgroundColor: "#FFE0B2"  # Light Orange
    prompt: |
      Run the project's test suite and report results.

      ### 1. Discover and Run Tests

      - Identify the test framework used (e.g., `go test`, `pytest`, `jest`, `cargo test`)
      - Run all tests or tests related to recent changes
      - Capture the full output

      ### 2. Analyze Results

      If tests pass:
      - Report success with a brief summary

      If tests fail:
      - For simple failures (typos, missing imports, obvious fixes):
        - Fix the issue immediately
        - Re-run the tests to verify the fix
        - Repeat until tests pass or failures are complex
      - For complex failures:
        - Report them for manual review

      ### 3. Summary Table

      Present a results table:

      | Test Group | Passed | Failed | Skipped | Status |
      |------------|--------|--------|---------|--------|
      | unit       | 45     | 0      | 2       | âœ…     |
      | integration| 12     | 1      | 0       | âŒ     |
      | e2e        | 8      | 0      | 0       | âœ…     |
      | **Total**  | **65** | **1**  | **2**   | âŒ     |

      ### 4. If Failures Remain

      For each unresolved failure:
      - **Test**: Name of the failing test
      - **Error**: The error message
      - **Cause**: Brief analysis of why it failed
      - **Suggested fix**: What needs to change

  - name: "Fix errors"
    backgroundColor: "#FFE0B2"  # Light Orange
    prompt: |
      Analyze and fix the errors shown.

      ### For each error:

      1. **Identify**: Quote the exact error message
      2. **Diagnose**: Explain the root cause
         - What triggered this error?
         - Why did the code fail?
      3. **Fix**: Implement the correction
         - Show the specific change made
         - Explain why this fixes the issue
      4. **Verify**: Confirm the fix works
         - Run the code/tests again
         - Check for related issues

      ### If multiple errors:
      - Fix in dependency order (fix causes before symptoms)
      - Group related errors that share a root cause
      - After fixing all, run a final verification

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DOCUMENTATION & EXPLANATION (Purple) - Docs and understanding
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - name: "Explain"
    backgroundColor: "#E1BEE7"  # Light Purple
    prompt: |
      Explain the code or concept we just discussed.

      ### Structure your explanation:

      1. **Purpose**: What problem does this solve? Why does it exist?
      2. **How it works**: Step-by-step walkthrough of the logic
      3. **Key components**: Important functions, classes, or patterns used
      4. **Data flow**: How data moves through the system
      5. **Edge cases**: Special conditions or error handling
      6. **Dependencies**: What this relies on, what relies on it

      Use concrete examples from the code. Avoid jargon unless you define it.

  - name: "Document"
    backgroundColor: "#E1BEE7"  # Light Purple
    prompt: |
      Add documentation to the code we just wrote.

      ### Add:

      1. **Package/module docs**: Purpose, main types, usage examples
      2. **Function/method docs**: What it does, parameters, return values, errors
      3. **Complex logic comments**: Explain non-obvious algorithms or business rules
      4. **TODO/FIXME**: Mark known limitations or future improvements
      5. **Examples**: Usage examples for public APIs

      ### Guidelines:
      - Explain WHY, not just WHAT (the code shows what)
      - Keep comments close to the code they describe
      - Update existing comments if code changed
      - Use the documentation style standard for this language/project
      - Don't state the obvious (avoid `// increment i` for `i++`)

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PERFORMANCE (Pink/Red) - Optimization
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - name: "Optimize"
    backgroundColor: "#F8BBD9"  # Light Pink
    prompt: |
      Identify and fix performance issues in the code.

      ### Analysis:

      1. **Profile first**: Identify actual bottlenecks, don't guess
      2. **Measure**: Establish baseline performance metrics

      ### Common optimizations:

      1. **Algorithmic**: Better data structures, reduced complexity (O(nÂ²) â†’ O(n log n))
      2. **Memory**: Reduce allocations, reuse buffers, avoid copies
      3. **I/O**: Batch operations, use buffering, async where appropriate
      4. **Caching**: Cache expensive computations, use memoization
      5. **Concurrency**: Parallelize independent work, reduce lock contention

      ### For each optimization:
      - Explain the bottleneck identified
      - Show the optimization applied
      - Quantify the improvement (or expected improvement)
      - Note any tradeoffs (memory vs speed, complexity vs performance)

      Avoid premature optimization. Focus on measurable improvements.

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # VERSION CONTROL (Teal/Cyan) - Git operations
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - name: "Create commits"
    backgroundColor: "#B2DFDB"  # Light Teal
    prompt: |
      Follow this workflow to create Git commits for the changes that we have in this repository:

      ### 1. Analyze Changes

      - Run `git status --porcelain` to list all changes
      - Verify the directory is a valid Git repository
      - Group changes by scope:
        - **Feature/component**: Related source files + their tests
        - **Type**: Config files, documentation, dependencies
        - **Path**: Files in the same module/directory
      - Make sure there are no staged changes. If there are, check
        how they relate to the changes you are seeing, if they should go first,
        or if they should be unstaged in order to be included in the commits
        you are going to propose.
      - If you are not sure about anything, just ask me.

      ### 2. Propose Commits

      Present a table, formatted as Makefown, with a each proposed commit, with

      SEQUENCE-NUMBER | COMMIT MESSAGE | FILES | REASON

      Use conventional commit prefixes: `feat:`, `fix:`, `docs:`, `refactor:`, `test:`, `chore:`
      Files can be expressed with Unix shell-style wildcards (e.g. `*.md`, `docs/*`).

      Order commits logically (e.g., implementation before documentation).

      ### 3. Wait for Approval

      Ask the user to:

      - **Approve all** - proceed with commits
      - **Modify** - specify changes (reorder, merge, split, edit messages)
      - **Cancel** - abort without committing

      **Do not commit until the user explicitly approves.**

      ### 4. Execute Commits

      For each approved commit:

      1. `git add <files>`
      2. `git commit -m "<message>"`

      Report success or errors after execution.

      ## Rules

      - Respect `.gitignore`
      - Skip empty commits
      - Handle binary/large files appropriately

  - name: "Create PR"
    backgroundColor: "#B2DFDB"  # Light Teal
    prompt: |
      Guide me through creating a pull request for the committed changes.

      ### 1. Prepare the Code

      **Format code:**
      - Identify and run the project's code formatters (e.g., `go fmt`, `prettier`, `black`, `rustfmt`)
      - Fix any formatting issues

      **Run tests:**
      - If tests were run recently in this session and no code changes have been made since, skip re-running
      - Otherwise, identify and run the project's test suite
      - If tests fail, report the failures and ask how to proceed

      ### 2. Ensure Feature Branch

      Check the current branch: `git branch --show-current`

      **If on main/master:**
      1. Review the commits to understand the changes: `git log --oneline -5`
      2. Create a descriptive branch name based on the changes:
         - Use existing project conventions (e.g., `feature/`, `fix/`, `chore/` prefixes)
         - Keep it short but descriptive (e.g., `feature/add-user-auth`, `fix/login-validation`)
      3. Create and switch to the new branch: `git checkout -b <branch-name>`

      **If already on a feature branch:**
      - Continue with the current branch

      ### 3. Sync with Upstream

      Ensure your branch is up-to-date before creating the PR:

      1. Fetch the latest changes: `git fetch origin`
      2. Identify the base branch: `git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'`
      3. Rebase onto the latest base branch: `git rebase origin/<base-branch>`
      4. If there are merge conflicts:
         - Report the conflicting files
         - Help resolve each conflict
         - Continue the rebase: `git rebase --continue`
         - If conflicts are too complex, ask the user how to proceed (abort, manual resolution, etc.)

      ### 4. Generate PR Title and Description

      **Analyze the commits** to create a good PR title and description:

      ```bash
      git log --oneline origin/<base-branch>..HEAD
      ```

      **PR Title:**
      - Summarize the overall change in one line (50-72 chars ideal)
      - Use conventional commit style if the project follows it (e.g., `feat: add user authentication`)
      - Be specific: "Fix login validation error" not "Fix bug"
      - If multiple commits, describe the overall goal, not individual changes

      **PR Description:**
      Structure the description as:

      ```markdown
      ## Summary
      Brief explanation of what this PR does and why.

      ## Changes
      - List key changes (can be derived from commit messages)
      - Group related changes together
      - Highlight any breaking changes or important notes

      ## Testing
      How the changes were tested (if applicable).

      ## Related Issues
      Fixes #123, Relates to #456 (if any issue references found in commits/branch)
      ```

      Present the proposed title and description for approval before creating the PR.

      ### 5. Push and Create Pull Request

      After approval, push the branch and create the PR:

      ```bash
      git push --force-with-lease -u origin HEAD
      gh pr create --title "<approved-title>" --body "<approved-description>"
      ```

      ### 6. Report PR Link

      After the PR is created, prominently display:

      ```
      âœ… Pull Request Created Successfully!

      ğŸ”— PR URL: <the-pr-url>

      Share this link to request reviews and approvals.
      ```

      Also show how to view the PR in browser: `gh pr view --web`

      ## Rules

      - Always run formatters and tests before creating the PR
      - Respect `.gitignore`
      - Never force push without explicit permission
      - Assume commits are already created (use "Create commits" prompt if needed first)

# Web server configuration
web:
  host: 127.0.0.1  # Local listener always binds to 127.0.0.1 for security
  port: 8080       # Local port (use 0 for random)
  external_port: -1  # External port when auth is enabled (-1 = disabled, 0 = random, >0 = specific port)
  api_prefix: /mitto  # URL prefix for API endpoints (security through obscurity). Set to "" to disable.
  theme: v2  # Options: "default", "v2" (modern theme)

  # hooks:
  #   up:
  #     command: echo "ngrok http ${PORT}"
  #     name: "ngrok"
  #   # down:
  #   #   command: echo "Shutting down server on port ${PORT}"
  #   #   name: "cleanup"

  # auth:
  #   simple:
  #     username: admin
  #     password: your-secure-password  # Use a strong password
  #   allow:
  #     ips:  # IP addresses/CIDR ranges that bypass authentication
  #       - 127.0.0.1
  #       - ::1
  #       - 192.168.0.0/24

  # security:
  #   # Trusted reverse proxies - only trust X-Forwarded-For from these IPs
  #   # Required when running behind nginx, Caddy, or cloud load balancers
  #   trusted_proxies:
  #     - 127.0.0.1
  #     - 10.0.0.0/8
  #     - 172.16.0.0/12
  #     - 192.168.0.0/16
  #
  #   # Allowed origins for WebSocket connections (CSRF protection)
  #   # If empty, only same-origin requests are allowed
  #   # Use "*" to allow all origins (not recommended for production)
  #   allowed_origins:
  #     - https://your-domain.com
  #     - https://your-tunnel.ngrok.io
  #
  #   # Rate limiting for API requests (per IP)
  #   rate_limit_rps: 10        # Requests per second (default: 10)
  #   rate_limit_burst: 20      # Maximum burst size (default: 20)
  #
  #   # WebSocket connection limits (per IP)
  #   max_ws_connections_per_ip: 10  # Default: 10
  #
  #   # Maximum WebSocket message size in bytes
  #   max_ws_message_size: 65536     # Default: 64KB

# UI settings
# ui:
#   # Confirmation dialogs - set to false to skip confirmations
#   confirmations:
#     delete_session: true  # Confirm before deleting a conversation (default: true)
#     quit_with_running_sessions: true  # Confirm before quitting with running conversations (default: true, macOS only)
#
#   # macOS desktop app settings (only applies to Mitto.app)
#   mac:
#     # Global hotkeys
#     hotkeys:
#       show_hide:
#         enabled: true
#         key: "cmd+ctrl+m"  # Hotkey to toggle app visibility
#     # Notification sounds
#     notifications:
#       sounds:
#         agent_completed: true  # Play a sound when the agent finishes
#     # Window behavior
#     show_in_all_spaces: false  # Show window in all macOS Spaces (requires restart)

# Conversation processing - transformations applied to user messages
# Processors are applied in order. Each processor specifies:
#   - when: "first" (first message only), "all" (every message), "all-except-first"
#   - position: "prepend" (before message) or "append" (after message)
#   - text: the content to insert
#
# Global processors defined here apply to all workspaces.
# Workspace-specific processors can be defined in <workspace>/.mittorc
# and will be merged with global processors (or override them with override: true).
#
# conversations:
#   processing:
#     processors:
#       # Add system context to the first message
#       - when: first
#         position: prepend
#         text: |
#           You are a helpful AI coding assistant.
#           Please follow best practices and be concise.
#
#           ---
#
#       # Add a reminder to all messages
#       - when: all
#         position: append
#         text: "\n\n[Remember: Provide working code examples]"
#
#       # Add continuation context after the first message
#       # - when: all-except-first
#       #   position: prepend
#       #   text: "[Continuing from previous context]\n\n"
#
#   # Message queue configuration
#   # When enabled, messages sent while the agent is busy are queued and
#   # automatically delivered when the agent becomes idle.
#   #
#   # queue:
#   #   # Enable/disable automatic queue processing (default: true)
#   #   # When false, messages remain in queue until manually sent or deleted
#   #   enabled: true
#   #
#   #   # Delay in seconds before sending the next queued message (default: 0)
#   #   # Useful to give users time to review agent responses before next message
#   #   delay_seconds: 0
#   #
#   #   # Maximum number of messages allowed in the queue (default: 10)
#   #   # When the queue is full, new messages are rejected with an error
#   #   max_size: 10
#   #
#   #   # Automatically generate short titles for queued messages (default: true)
#   #   # Uses the auxiliary conversation to create 2-3 word titles
#   #   auto_generate_titles: true

# Follow-up suggestions configuration
# When enabled, agent messages are analyzed asynchronously to identify
# questions or follow-up prompts, and suggested response buttons are
# displayed to the user.
conversations:
  action_buttons:
    enabled: true  # Enable follow-up suggestions by default
